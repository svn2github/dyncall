\subsection{MIPS Calling Convention}

\paragraph{Overview}

The MIPS family of processors is based on the MIPS processor architecture.
Multiple revisions of the MIPS Instruction sets, namely MIPS I, MIPS II, MIPS III, MIPS IV, MIPS32 and MIPS64.
Today, MIPS32 and MIPS64 for 32-bit and 64-bit respectively.
Add-on extensions: 

\begin{description}
\item [MIPS-3D] simple floating-point SIMD instructions dedicated to common 3D tasks
\item [MDMX] (MaDMaX) more extensive integer SIMD instruction set using 64 bit floating-point registers.
\item [MIPS16e] adds compression to the instruction stream to make programs take up less room (allegedly a repsonse to the Thumb encoding in the ARM architecture)
\item [MIPS MT] multithreading additions to the system similar to HyperThreading.
\end{description}

Unfortunately, there is actually no such thing as "The MIPS Calling Convention".  Many possible conventions are used
by many different programmers and assemblers. Several different approaches are
outlined in text, but none is fully described or documented.

Calling conventions:
\begin{itemize}
\item 32
\item o64
\item n32
\item 64
\item eabi
\end{itemize}

\subsubsection{MIPS EABI Calling Convention}

The following EABI is in use on the Playstation Portable using the PSPSDK.

\begin{tabular}[ll]
$0        & $zero     & Hardware zero \\
$1        & $at       & Assembler temporary \\
$2-$3     & $v0-$v1   & Function results \\
$4-$11    & $a0-$a7   & Integer arguments\\
$12-$15   & $t4-$t7   & Temporaries \\
$16-$23   & $s0-$s7   & Saved \\
$24       & $t8       & Temporary \\
$25       & $t9       & Temporary \\
$26-$27   & $kt0-$kt1 & Reserved for kernel \\
$28       & $gp       & Global pointer \\
$29       & $sp       & Stack pointer \\
$30       & $s8       & Frame pointer \\
$31       & $ra       & Return address \\
hi, lo    &           & Multiply/divide sepcial registers \\
$f0,$f2   &           & Floating point function results \\
$f1,$f3   &           & Floating point temporaries \\
$f4-$f11  &           & Floating point temporaries \\
$f12-$f19 &           & Floating point single arguments\\
$f20-$f23 (32-bit)   &         & Floating point temporaries (32bit)\\
$f24-$f31 (64-bit)   &         & Floating point (64 bit)\\
$f20-$f31 even (n32) &         & Floating point temporaries\\
$f20-$f31 odd (n32)  &         & Floating point\\
\end{tabular}

\begin{itemize}
\item Stack always aligned to 8 bytes
\item $a0-$a3 are not required to be preserved
\end{itemize}

\subsubsection{O32}

\paragraph{Register Usage}

\begin{tabular}[lll]
$0             & $0           & Always 0 \\
$1             & $at          & The \emph{Assembler Temporary} used by the assembler in expanding pseudo-ops. \\
$2-$3          & $v0-$v1      & These registers contain the \emph{Returned Value} of a subroutine; if the value is 1 word only $v0 is significant. \\
$4-$7          & $a0-$a3      & The \emph{Argument} registers, these registers contain the first 4 argument values for a subroutine call. \\
$8-$15,$24,$25 & $t0-$t9      & The \emph{Temporary Registers}. \\
$16-$23        & $s0-$s7      & The \emph{Saved Registers}. \\
$26-$27        & $k0-$k1      & The \emph{Kernel Reserved registers}. DO NOT USE \\
$28            & $gp          & The \emph{Globals Pointer} used for addressing static global variables. \\
$29            & $sp          & The \emph{Stack Pointer}.
$30            & $fp (or $s8) & The \emph{Frame Pointer}.
$31            & $ra          & The \empg{Return Address} in a subroutine call.
$f0-$f2        &              & Used to hold floating-point type function results ($f0) and complex type function results ($f0 has the real part, $f2 has the imaginary part).\\
$f4-$f10       &              & Temporary registers, not preserved across procedure calls.\\
$f12-$f14      &              & Use to pass the first two single or double precision actual arguments, whose values ar not preserved across procedure calls.\\
$f16-$f18      &              & Temporary registers.\\
$f20-$f30      &              & Saved registers, whose values must be preserved across procedure calls.\\
\end{tabular}

\paragraph{Stack layout}

\begin{itemize}
\item localdata
\item padding
\item return address
\item saved reg k-1 .. reg 0
\item arg n-1... arg0
\end{itemize}

