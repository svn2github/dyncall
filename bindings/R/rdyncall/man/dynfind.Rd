\name{dynfind}
\alias{dynfind}
\alias{pathsFromEnv}
\title{Portable sarching and loading of shared libraries.}
\description{Searches for a shared library in standard locations by short names.}
\usage{
dynfind(libnames, auto.unload=TRUE)
}
\arguments{
  \item{libnames}{character vector strings specifying short library names.}
  \item{auto.unload}{logical: if \code{TRUE} then a finalizer is registered that closes the library on garbage collection. See \code{\link{.dynload}} for details.}
}
\details{

This function offers a platform portable interface for loading shared libraries. Users can specify a
library via a list of \emph{short library names} - a fragment of the \emph{full} library name.

A fully qualified library file path can be divided into groups, as given below:

\tabular{c}{
\emph{location} \emph{prefix} \emph{libname} \emph{suffix}
}

When \code{dynfind} searches for a library, a list of possible file paths is generated by permutation of the components of a fully qualified library file path.
Each file path is tried using the run-time dynamic linker of the OS via \code{\link{.dynload}}. If successful, the search stops and the opened library and the path is returned.

Here is an example of component values for each component:

\itemize{
  \item locations: '/usr/local/lib/', '/Windows/System32/'.
  \item prefixes: 'lib' (for Unix-flavour), '' (for Windows-flavour).
  \item suffixes: '.dll' (Windows), '.dylib' (Mac OS X/iOS), '.so' (ELF) and '' (for Mac OS X Frameworks).
  \item libnames: 'c', 'msvcrt'.
}

The vector of \emph{locations} is initialized by environment variables such as '\code{PATH}' on Windows and 
\code{LD_LIBRARY_PATH} on Unix-flavour systems in additional to some hardcoded locations:
\file{/opt/local/lib}, 
\file{/usr/local/lib}, 
\file{/usr/lib} and 
\file{/lib}.
(The set of hardcoded locations might expand and change within the next minor releases).

Some libraries such as the Standard C Library do not have a single standard \emph{short library name}. Hence, one can give a vector of short names.
For example, to load the Standard C Library across Windows and Unix-like systems, the function call \code{dynfind(c("msvcrt","c"))} 
would locate \code{MSVCRT.dll} on Windows and \code{libc.so} ( or \code{libc.so.6} ) on Unix-Systems.

The file extension is either taken to be '\code{.dll}' (Windows), '\code{.dylib}' (Mac OS X), '\code{.so}' (ELF-based - Linux, FreeBSD, NetBSD, OpenBSD, Solaris).

On Mac OS X, frameworks are also searched for by a fragment name and this 
happens before the normal shared library search procedure is started with a slightly different pattern:

\tabular{c}{
\emph{frameworksLocation} \code{Frameworks/} \emph{fragmentName} \code{.framework/} \emph{fragmentName}
}

The \emph{frameworksLocation} is a vector of locations such as \code{/System/Library/} and \code{/Library/}.

Loading of the library is carried out by \code{\link{.dynload}} passing over the parameter \code{auto.unload}.

}
\value{
See \code{\link{.dynload}}.  
}
\seealso{\code{\link{.dynload}}}
\keyword{programming}
\keyword{interface}

