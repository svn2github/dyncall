\documentclass{article}
\begin{document}
\title{Multimedia programming with R and rdyncall}
\author{Daniel Adler}
\maketitle

Via the rdyncall package it is possible to write system-level
software in R. In this vignette we focus on multimedia programming
in R using the SDL and OpenGL shared libraries.
This vignette describes several issues involved in using the rdyncall
package with C level interfaces of OpenGL and SDL. This text is
not at all a reference to OpenGL or SDL. There are other much better
text books and tutorials available.

Initially, one needs to dynamically link SDL, OpenGL and OpenGL Utility Libraryto the R session.
Luckily, there are dynports available.

library(rdyncall)
dynport(SDL)
dynport(GL)
dynport(GLU) 

We need to initialize the SDL libraray.

subsystems <- SDL_INIT_VIDEO
SDL_Init(subsystems)

The variable subsystem is a bitmask encoded in a double constant, also
the C API expects to have an unsigned int. rdyncall cares for a correct
coercion to unsigned int. By addition of several double constants, 
we can initialize multiple subsystems.

To see what subsystems SDL offers, we can explore the SDL dynport using e.g.
the apropos base R command:

apropos("SDL_INIT_")

Let us open a new OpenGL Display using SDL_SetVideoMode. The parameters are:
\begin{description}
\item[width] The width in pixel.
\item[height] The height in pixel
\item[bpp]
\item[flags] Bit flags to be combined with '+'. SDL_OPENGL and SDL_DOUBLEBUF typical for OpenGL real-time renderings.
\end{description}

Some useful Flags:

\begin{description}
\item[SDL_OPENGL] Request an OpenGL context to be initialized for this surfacce.
\item[SDL_DOUBLEBUF] Rendering into a back buffer and allow to flip the surfaces in one shot.
\item[SDL_FULLSCREEN] Put the display in fullscreen mode.
\end{description}

width <- 640
heigth <- 480
bitsperpixel <- 32
flags <- SDL_OPENGL+SDL_DOUBLEBUF
surface <- SDL_SetVideoMode(width,height,bitsperpixel,flags)

The surface object can be printed in R:

print(surface)

To clear the display with a constant color value, one needs to specifying the
\emph{clear color} first and then clear the \emph{color buffer}.

glClearColor(0.1,0.2,0.3,0.0)
glClear(GL_COLOR_BUFFER_BIT)

To see the results, we need to flip the surface - all operations in
\emph{double buffering} graphics mode are done in the back and will
be presented in one shot to prevent semi-finished drawing artefacts.

SDL_GL_SwapBuffers()

This was interactive, but SDL and OpenGL are designed for writing
multimedia applications and we do this in R.

These types of applications run a simple loop such as the interactive
loop of R (read-evaluate-print loop).
The loop will run until the application should quit. A reference play time
will be computed for each loop iteration using SDL_GetTicks (divided by 1000
gives seconds).
We will clear our display using a blinking color which changes intensity from
black to a specified color. We drop the loop after 3 seconds.

draw <- function() {
  # nothing so far
}

mainloop <- function()
{
  quit <- FALSE

  starttime <- SDL_GetTicks() / 1000

  playtime  <- 0
  blinkspeed <- 2.0 
  while(!quit) {
    # blink the screen using an intensity blending from 0 to 1 
    intensity <- playtime %% blinkspeed / blinkspeed
    glClearColor(0.8*intensity,0.6*intensity,1.0*intensity,0.0)
    glClear(GL_COLOR_BUFFER_BIT)
    
    draw()
    
    SDL_GL_SwapBuffers()
  
    # update playtime:
    now <- SDL_GetTicks() / 1000.0
    playtime <- now - starttime

    # stop after three seconds
    if (playtime > 3.0) quit <- TRUE
  }
}
# run the loop
mainloop()

Rendering 3D graphics 

To render a 3D scene, one specifies the 3D projection first, sets up the
camera position in space and then specifies the positions and primitive
geometries such as points, lines and triangles.

First we specify the attributes of our virtual camera, that is 
the field of view angle, the aspect ratio between width and height (which
should match the one of our surface) and the near and far z-plane orthogonal
to the camera center projection vector.

setupProjection <- function()
{
  glMatrixMode(GL_PROJECTION)
  glLoadIdentity()
  fovy   <- 60.0
  aspect <- width / height
  znear  <- 10
  zfar   <- 100
  gluPerspective(fovy, aspect, znear, zfar)
}

Next, we need to setup the position of our camera in space using
the gluLookAt API which gets three vectors eye, center and up.

setupCamera <- function(eye=c(0,0,-2),center=c(0,0,0),up=c(0,1,0))
{
  glMatrixMode(GL_MODELVIEW)
  glLoadIdentity()
  gluLookAt(eye[[1]],eye[[2]],eye[[3]],center[[1]],center[[2]],center[[3]],up[[1]],up[[2]],up[[3]])
}

What follows is a short routine to draw a million 3D coordinates generated
by rnorm.

draw <- function()
{
  npoints <- 1000000
  dims    <- 3
  data    <- rnorm(npoints*dims)
  type    <- GL_DOUBLE
  stride  <- 0
  glEnableClientState(GL_VERTEX_ARRAY_POINTER)
  glVertexPointer(dims,type,stride,data)
  stgrtindex <- 0
  glDrawArrays(GL_POINTS, startindex, npoints)
  glDisableClientState(GL_VERTEX_ARRAY_POINTER)
}

We will exchange the default behaviour of stopping after three seconds
with processing user-input events such as mouse, keybaord and joystick input
or pressing the close window button.

SDL uses a C structure to report user-interface events. One calls
a function called SDL_PollEvent given the reference of this structure.

processEvents <- function(env)
{
  evt <- new.struct(SDL_Event)
  quit <- FALSE
  while(!quit) {
    while( SDL_PollEvent(evt) ) {
      type <- evt$type
      if (type == SDL_QUIT) {
        env$quit <- TRUE
      } else if (type == SDL_MOUSEMOTION) {
        motion <- evt$motion
        cat(motion$xrel,",",motion$yrel,"\n")
      }
    }
  }
}


clearSurface <- function(red, green, blue, color, alpha=0)
{
  if (!is.missing(color))
  {
    rgb   <- as.vector(col2rgb(color)/255)
    red   <- rgb[[1]]
    green <- rgb[[2]]
    blue  <- rgb[[3]]
  }
  glClearColor(red,green,blue,alpha)
  glClear(GL_COLOR_BUFFER_BIT)
}

clearSurface("white")




The initialization time for making a dynport available is quiet fast.

The dynamic linkage time is quiet fast.

